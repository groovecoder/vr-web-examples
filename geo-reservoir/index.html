<html>
  <head>
    <title>My first Three.js app</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/VRControls.js"></script>
    <script src="js/VREffect.js"></script>
    <script src="js/wells.js"></script>
    <script src="https://js.leapmotion.com/leap-0.6.4.js"></script>
    <script src="https://js.leapmotion.com/leap-plugins-0.1.8.min.js"></script>
    <script src="https://js.leapmotion.com/leap.rigged-hand-0.1.5.min.js"></script>
    <script>
      var display_mode;
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, .1, 15000 );
/*
      var cameraAngle = 0;
      var orbitRange = 1;
      var orbitSpeed = 2 * Math.PI/360;
      var desiredAngle = 90 * Math.PI/180;
*/
      camera.position.set(-95, 1, 39.95);
      var orbit_controls = new THREE.OrbitControls( camera );
      orbit_controls.damping = .002;
      orbit_controls.center.set(-120, 1, 39.95);

      var vr_controls = new THREE.VRControls( camera );

      var renderer = new THREE.WebGLRenderer( {antialias: true} );
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );

      var vr_effect = new THREE.VREffect( renderer );
		  vr_effect.setSize( window.innerWidth, window.innerHeight );

      var axisHelper = new THREE.AxisHelper( 100 );
      scene.add( axisHelper );
/*
      var cameraHelper = new THREE.CameraHelper( camera );
      scene.add( cameraHelper );
*/

      var kb_geo = new THREE.Geometry();
      var kb_z_values = [];
      var cylinders = [];
      for ( var i = 0; i < wells.length; i ++ ){
          var well = wells[i];

          // get each well's lng, lat for x, y positioning
          var x = well.lng;
          var y = well.lat;

          // x,y,z vectors where the kelly bushes are
          var kb_z = 0;
          if (well.kb && well.kb.value > 0) {
              kb_z = well.kb.value / 1000;
              kb_z_values.push(kb_z);
          }
          var v = new THREE.Vector3( x, kb_z, y );
          kb_geo.vertices.push( v );

          // cylinders where the wells detect a reservoir
          var cyl_height = (well.reservoir.bottom - well.reservoir.top) / 1000;
          if ( cyl_height > 0) {
            var cyl_geo = new THREE.CylinderGeometry( .01, .01, cyl_height );
            var cyl_mat = new THREE.MeshBasicMaterial( { color: 0x888800 } );
            var cyl = new THREE.Mesh( cyl_geo, cyl_mat );
            cyl.position.set(x, 0 - (well.reservoir.top / 1000), y );
            cylinders.push( cyl );
            scene.add( cyl );
          }
      }



      // go back and set 0 kb_z values to average of others'
      kb_z_sum = 0;
      for (var i = 0; i < kb_z_values.length; i++) {
          kb_z_sum += kb_z_values[i];
      }
      var kb_z_avg = kb_z_sum / kb_z_values.length;
      for (var i = 0; i < kb_geo.vertices.length; i++ ) {
        if (kb_geo.vertices[i].z == 0) {
          kb_geo.vertices[i].z = kb_z_avg;
        }
      }
      
      console.log(cylinders);

      var material = new THREE.PointCloudMaterial( { size: .03, color: 0x00ff00 } );
      var kbPointCloud = new THREE.PointCloud( kb_geo, material );
      scene.add( kbPointCloud );

      ctv = kbPointCloud.geometry.vertices[25];
      ctv3 = new THREE.Vector3(ctv.x, ctv.y, ctv.z)
      camera.lookAt(ctv3);
//    orbit_controls.center.set(ctv.x, ctv.y, ctv.z);

      var render = function () {
        if ( display_mode == 'vr' ) {
            vr_controls.update();
            vr_effect.render(scene, camera);
        } else {
/*
            camera.lookAt(ctv3);
            if (cameraAngle == desiredAngle) { orbitSpeed = 0; }
            else {
              cameraAngle += orbitSpeed;
              camera.position.x = Math.cos(cameraAngle) * orbitRange;
              camera.position.y = Math.sin(cameraAngle) * orbitRange;
            }
*/
            orbit_controls.update();
            renderer.render(scene, camera);
        }
        requestAnimationFrame( render );
      };

      render();

      /*
      Listen for keyboard events to enter full-screen VR mode.
      */
      function onkey(event) {

        if (!(event.metaKey || event.altKey || event.ctrlKey)) {
          event.preventDefault();
        }

        if (event.charCode == 'v'.charCodeAt(0)) { // v
          display_mode = 'vr';
          vr_controls.zeroSensor();
          vr_effect.setFullScreen( true );
        } else if (event.charCode == 'd'.charCodeAt(0)) { // d
          display_mode = '';
          renderer.setSize( window.innerWidth, window.innerHeight );
        }
      };

	  window.addEventListener("keypress", onkey, true);

    (window.controller = new Leap.Controller).use('riggedHand', {
        parent: scene,
        renderFn: function() {
          if ( display_mode == 'vr' ) {
            vr_effect.render( scene, camera);
          } else {
            renderer.render( scene, camera );
          }
        },
        materialOptions: {
            wireframe: true
        },
        offset: new THREE.Vector3(0,-200,-250),
        positionScale: 2
    }).connect()

    </script>
  </body>
</html>
